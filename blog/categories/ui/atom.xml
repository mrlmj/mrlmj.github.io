<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ui | AndroidDev]]></title>
  <link href="http://www.monkeyliu.com/blog/categories/ui/atom.xml" rel="self"/>
  <link href="http://www.monkeyliu.com/"/>
  <updated>2018-04-13T10:55:57+08:00</updated>
  <id>http://www.monkeyliu.com/</id>
  <author>
    <name><![CDATA[放开那个猴子]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[路径动画的实现方案]]></title>
    <link href="http://www.monkeyliu.com/blog/2018/04/08/path-tracing/"/>
    <updated>2018-04-08T20:10:38+08:00</updated>
    <id>http://www.monkeyliu.com/blog/2018/04/08/path-tracing</id>
    <content type="html"><![CDATA[<p>UI开发中有时会遇到这样的效果（重点看对号√的动画实现）</p>

<p><img src="/images/articles/path_tracing.gif" alt="path tracing" /></p>

<p>这篇文章就总结下，如何实现这样的一个UI动效。</p>

<!-- more -->


<h3>基本分析</h3>

<p>我们都知道，使用Android的Path Api可以很容易地画出一个对号（或者任意其他的不规则图形），实现这个效果的难点在于怎么以动画的形式逐渐地把这个路径给绘制出来。这里把路径(Path)从0到1绘制出来的过程称之为路径追踪（Path Tracing).</p>

<p>[@Path的绘制API]</p>

<pre><code class="java">//构造任意一个path
Path path = new Path();
path.moveTo(0, 0);
path.lineTo(100,100);
path.lineTo(100, 200);
//画出path
cavas.drawPath(path, paint);
</code></pre>

<h3>实现方案一（PathMeasure)</h3>

<p>Android提供了PathMeasure类，用来进行路径的计算，可以用来实现路径追踪。</p>

<p>创建PathMeasure：</p>

<pre><code class="java">PathMeasure pathMeasure = new PathMeasure(Path path, boolean forceClosed);
</code></pre>

<p>或者也可以使用无参构造函数:</p>

<pre><code class="java">PathMeasure pathMeasure = new PathMeasure();
pathMeasure.setPath(Path path, boolean forceClosed);
</code></pre>

<p>第一个参数传入需要进行计算的路径，第二个参数指示是否将路径闭合。</p>

<p>几个有用的API</p>

<ol>
<li>获取路径的像素长度：</li>
</ol>


<pre><code class="java">pathMeasure.getLength();
</code></pre>

<ol>
<li>获取路径的片段：</li>
</ol>


<pre><code class="java">pathMeasure.getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)
</code></pre>

<p>这个方法是绘制路径追踪动画的核心方法，通过这个方法可以获取整个Path你想要的片段，<strong>保持起点不变，终点一点点变长</strong>，就可以将路径一点一点地绘制出来了。</p>

<p><em>参数介绍</em>：</p>

<ul>
<li>startD和stopD：开始距离和结束距离，控制截取的Path的内容。</li>
<li>dst:将截取的路径保存到这个Path中，之后绘制这个Path即可。</li>
<li>startWithMoveTo: 通常为true，表示对dst path先调用moveTo移动到起点的位置。</li>
</ul>


<p>相当于</p>

<pre><code class="java">dst.moveTo(起点);
dst.lineTo(终点);
</code></pre>

<p>如果设为false，经过测试，相当于:</p>

<pre><code class="java">dst.lineTo(起点);
dst.lineTo(终点);
</code></pre>

<p>一个Path如果直接lineTo某个点，隐式地在最开始添加了一个moveTo(0,0)，这种情况下获取的Path实际上起点连接到了(0,0)点。</p>

<p>使用上面两个API，结合属性动画，实现路径追踪的效果：</p>

<pre><code class="java">public class RouteTraceView extends View {

    private Path mDstPath = new Path();
    private float mEndDistance;
    private PathMeasure mPathMeasure;

    private Paint mPaint;

    public RouteTraceView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    private void init() {
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mPaint.setColor(Color.RED);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeWidth(10);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        mDstPath.reset();
        mDstPath.lineTo(0, 0); //这样据说是因为硬件加速的bug，但是我去掉也没发现什么问题
        mPathMeasure.getSegment(0, mEndDistance, mDstPath, false);
        canvas.drawPath(mDstPath, mPaint);
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        //要动态绘制出来的路径
        Path path = new Path();
        path.moveTo(0, 50);
        path.lineTo(100, 100);
        path.lineTo(100, 200);

        mPathMeasure = new PathMeasure();
        mPathMeasure.setPath(path, false);
        final float length = mPathMeasure.getLength();

        ValueAnimator valueAnimator = ValueAnimator.ofFloat(0, 1);
        valueAnimator.setDuration(3000);
        valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                //动画的形式改变终点的距离
                mEndDistance = (float) animation.getAnimatedValue() * length;
                invalidate();
            }
        });
        valueAnimator.start();
    }
}
</code></pre>

<p>是不是很简单，对于任意一个Path，都能通过这种改变终点距离的方式，一点点地追踪出来~</p>

<h3>实现方案二（DashPathEffect）</h3>

<p>这种方式比较黑科技，算是奇技淫巧，用起来也是十分方便。</p>

<p>Paint画笔有这样一个方法:</p>

<pre><code class="java">mPaint.setPathEffect(PathEffect effect);
</code></pre>

<p>用来给画出的路径添加bling bling的特效。</p>

<h5>PathEffect的实现类有以下几个：</h5>

<ul>
<li>CornerPathEffect</li>
</ul>


<p><img src="/images/articles/path_affect_0.jpg" alt="corner" /></p>

<ul>
<li>DecretePathEffect  随机偏移的乱七八糟的效果</li>
</ul>


<p><img src="/images/articles/path_affect_1.jpg" alt="decrete" /></p>

<ul>
<li>DashPathEffect</li>
</ul>


<p><img src="/images/articles/path_affect_2.jpg" alt="dash" /></p>

<ul>
<li><p>PathDashPathEffect  用某个Path来绘制虚线</p>

<p><img src="/images/articles/path_affect_3.jpg" alt="path dash" /></p></li>
<li><p>SumPathEffect  组合两种Effect，分别按照两种PathEffect对路径进行绘制</p>

<p><img src="/images/articles/path_affect_4.jpg" alt="corner" /></p></li>
<li><p>ComposePathEffect 组合两种Effect，先对目标路径应用第一个Effect，对改变后的Path再应用第二个Effect</p>

<p><img src="/images/articles/path_affect_5.jpg" alt="corner" /></p></li>
</ul>


<p>那这些PathEffect跟要实现的路径追踪有半毛钱关系吗？？？</p>

<p>Too young too simple！看我是怎么用DashPathEffect来装逼的！</p>

<h5>先来具体看一下DashPathEffect的构造方法：</h5>

<p>[@DashPathEffect构造方法]</p>

<pre><code class="java">public DashPathEffect(float intervals[], float phase){}
</code></pre>

<ul>
<li>intervals是一个数组，它的大小必须为偶数，最少两个。其中的元素按照【画线长度，空白长度，画线长度，空白长度….】排列。</li>
</ul>


<p>比如：</p>

<pre><code class="java">PathEffect pathEffect = new DashPathEffect(new float[]{20, 10, 5, 10}, 0); 
</code></pre>

<p>就表示在路径上先画20px的线，再画10px的空白，再画5px的线，再画10px的空白，再循环以此类推。</p>

<ul>
<li>phase表示相位的偏移，经过测试<strong>phase为正时，虚线整体向起点方向偏移</strong>，比如上述代码中offset如果为20,则我们先看到的则是10px的空白了~</li>
</ul>


<p><strong>黑科技马上要来了！</strong></p>

<p>思考下面这种写法：</p>

<pre><code class="java">//要动态绘制出来的路径
Path path = new Path();
path.moveTo(0, 50);
path.lineTo(100, 100);
path.lineTo(100, 200);
//拿到Path的长度
PathMeasure pathMeasure = new PathMeasure();
pathMeasure.setPath(path, false);
float pathLength = pathMeasure.getLength();
//特效
DashPathEffect dashPathEffect = new DashPathEffect(new float[]{pathLength, pathLength}, 0);
mPaint.setPathEffect(dashPathEffect);
canvas.drawPath(path, mPaint);
</code></pre>

<p>其中intervals数组画线的长度和空白的长度都是path的长度。</p>

<p>按照前面讲的，这样整个路径画出来，先是实线部分，就把路径填满了，这个路径一下子全画了出来。</p>

<p>稍微修改一下，将phase改为pathLength：</p>

<pre><code class="java">//特效
DashPathEffect dashPathEffect = new DashPathEffect(new float[]{pathLength, pathLength}, pathLength);
</code></pre>

<p>按照前面讲的，虚线整体向起点移动pathLength个像素，这样实线部分完全移出了路径，隐藏起来了，显示的完全是空白的部分（长度也是pathLength）。</p>

<p><strong>So</strong></p>

<p>完全隐藏和完全显示两个状态都有了，剩下的中间状态，通过一个属性动画将phase从pathLength变到0，整个路径就慢慢地显示出来了！！!</p>

<p>至此，便利用PathEffect的虚线效果结合phase的偏移，将路径追踪效果轻松实现了~</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.curious-creature.com/2013/12/21/android-recipe-4-path-tracing/">http://www.curious-creature.com/2013/12/21/android-recipe-4-path-tracing/</a></li>
<li><a href="https://www.jianshu.com/p/81150d4740a4">https://www.jianshu.com/p/81150d4740a4</a></li>
<li><a href="http://hencoder.com/ui-1-2/">http://hencoder.com/ui-1-2/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android之Theme、Style、Attr]]></title>
    <link href="http://www.monkeyliu.com/blog/2017/11/09/android-theme-style-attr/"/>
    <updated>2017-11-09T19:15:01+08:00</updated>
    <id>http://www.monkeyliu.com/blog/2017/11/09/android-theme-style-attr</id>
    <content type="html"><![CDATA[<p>Android UI开发中经常会涉及到Theme、Style、Attr等概念，熟悉掌握这些概念能够帮助我们快速实现想要的UI效果，另外自定义View也经常需要使用到这些东西。</p>

<!-- more -->


<h3>概念</h3>

<ul>
<li><strong>Attr</strong> 属性——基础单元，在Theme/Style/XML文件中作为Key使用，指定相应的value。</li>
</ul>


<p>定义方式：</p>

<pre><code class="xml">&lt;attr name="borderWidth" format="dimen" /&gt;
</code></pre>

<p>使用方式:</p>

<pre><code class="xml">&lt;View
      android:layout_width="wrap_content"
      android:layout_height="wrap_content"
      app:borderWidth="10dp" /&gt;
</code></pre>

<p>或</p>

<pre><code class="java">int attr = R.attr.borderWidth;
</code></pre>

<p>可以将多个关联属性分组管理:</p>

<pre><code class="java">&lt;declare-styleable name="MyButton"&gt;
    &lt;attr name="buttonWidth" format="dimension" /&gt;
    &lt;attr name="buttonHeight" format="dimension" /&gt;
    &lt;attr name="buttonColor" format="color" /&gt;
&lt;/declare-styleable&gt;
</code></pre>

<p>通过以下方式可以访问到一个属性数组:</p>

<pre><code class="java">int[] attrs = R.styleable.MyButton;
</code></pre>

<ul>
<li><strong>Style</strong> 样式集合，将多个属性放在一起，达到复用的目的。</li>
</ul>


<p>例如：</p>

<pre><code class="xml">&lt;Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:gravity="center"
        android:textSize="20sp"
        android:textColor="#FF000" /&gt;
</code></pre>

<p>抽离出一些公共的属性作为Style:</p>

<p>```xml</p>



<pre><code>
引用Style:
</code></pre>

<p><Button
        android:id="@+id/button"
        style="@style/myButtonStyle" />
```</p>

<ul>
<li><strong>Theme</strong> 主题，相当于一个大的Style，作用在应用的层次。其中会包含一些Window相关的属性，比如:
<code>xml
&lt;item name="windowBackground"&gt;?attr/colorBackground&lt;/item&gt;
&lt;item name="windowClipToOutline"&gt;true&lt;/item&gt;
&lt;item name="windowFrame"&gt;@null&lt;/item&gt;
&lt;item name="windowNoTitle"&gt;false&lt;/item&gt;
&lt;item name="windowFullscreen"&gt;false&lt;/item&gt;
&lt;item name="windowOverscan"&gt;false&lt;/item&gt;
&lt;item name="windowIsFloating"&gt;false&lt;/item&gt;
</code></li>
</ul>


<p>一些组件(Dialog，View等）的统一样式，比如：
<code>xml
&lt;item name="dialogTheme"&gt;@style/ThemeOverlay.Material.Dialog&lt;/item&gt;
&lt;item name="dialogTitleDecorLayout"&gt;@layout/dialog_title_material&lt;/item&gt;
&lt;item name="dialogPreferredPadding"&gt;@dimen/dialog_padding_material&lt;/item&gt;
&lt;item name="searchViewStyle"&gt;@style/Widget.Material.SearchView&lt;/item&gt;
&lt;item name="searchDialogTheme"&gt;@style/Theme.Material.SearchBar&lt;/item&gt;
&lt;item name="numberPickerStyle"&gt;@style/Widget.Material.NumberPicker&lt;/item&gt;
&lt;item name="calendarViewStyle"&gt;@style/Widget.Material.CalendarView&lt;/item&gt;
&lt;item name="timePickerStyle"&gt;@style/Widget.Material.TimePicker&lt;/item&gt;
&lt;item name="timePickerDialogTheme"&gt;?attr/dialogTheme&lt;/item&gt;
&lt;item name="datePickerStyle"&gt;@style/Widget.Material.DatePicker&lt;/item&gt;
&lt;item name="datePickerDialogTheme"&gt;?attr/dialogTheme&lt;/item&gt;
</code></p>

<p>主题相当于应用的一套皮肤，这套皮肤制定了各个组件的显示风格，使之具有统一性。我们熟知的有<code>Theme.Holo</code>,<code>Theme.Material</code>等等。</p>

<h3>Style、Theme作用在View上的流程</h3>

<p><strong>问题：</strong>既然使用Style、Theme都可以给View一个样式，那么他们是怎样作用在View上的呢？他们两个的优先级又是怎么样的。</p>

<p>这里说一下优先级，日常的开发中应该都能够得出一个经验：<strong>layout布局文件中属性 > style样式 > Theme主题</strong></p>

<p>拿一个Button举例，如果在布局文件中给Button设置了<code>android:background="XXX"</code> 或者抽离到Style中再应用，那么Button就显示了我们指定的背景。 如果没有设置背景属性，Button仍然是有一个背景的。这个默认背景就是应用到了Theme中的样式，并且对于不同的主题有不同的样式~</p>

<p>然后重点来说一下样式是怎样作用到View上的，对这个过程进行深入的理解。同样拿一个Android的View来举例：<code>TextView</code>，看看它是怎么应用样式的。</p>

<p>[@TextView] 构造方法:</p>

<pre><code class="java">public TextView(Context context) {
        this(context, null);
}

public TextView(Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, com.android.internal.R.attr.textViewStyle);
}

public TextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, 0);
}

@SuppressWarnings("deprecation")
public TextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
}
</code></pre>

<p>我们继承Android的View来自定义View时，通过会被要求继承四个的构造方法中的一个。对于XML中布局的View，被调用2个参数的构造方法来new一个实例，其中attrs就是布局的属性集，其中包含了这个View的所有样式。</p>

<p>TextView所有的构造函数最终都指向最长参数的构造函数：</p>

<pre><code class="java">public TextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);

        final Resources.Theme theme = context.getTheme();
        TypedArray a = theme.obtainStyledAttributes(attrs,
                com.android.internal.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes);
        TypedArray appearance = null;
        int ap = a.getResourceId(
                com.android.internal.R.styleable.TextViewAppearance_textAppearance, -1);
        a.recycle();
        if (ap != -1) {
            appearance = theme.obtainStyledAttributes(
                    ap, com.android.internal.R.styleable.TextAppearance);
        }
        if (appearance != null) {
            int n = appearance.getIndexCount();
            for (int i = 0; i &lt; n; i++) {
                int attr = appearance.getIndex(i);

                switch (attr) {
                case com.android.internal.R.styleable.TextAppearance_textColorHighlight:
                    textColorHighlight = appearance.getColor(attr, textColorHighlight);
                    break;

                case com.android.internal.R.styleable.TextAppearance_textColor:
                    textColor = appearance.getColorStateList(attr);
                    break;
                //省略大量Case
            }

            appearance.recycle();
        }

        a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes);

        int n = a.getIndexCount();
        for (int i = 0; i &lt; n; i++) {
            int attr = a.getIndex(i);

            switch (attr) {
            case com.android.internal.R.styleable.TextView_editable:
                editable = a.getBoolean(attr, editable);
                break;

            case com.android.internal.R.styleable.TextView_inputMethod:
                inputMethod = a.getText(attr);
                break;
            //省略大量Case
        }
}
</code></pre>

<p>其中最核心的一个方法是<code>context.obtainStyledAttributes(AttributeSet, int[] attrs, defStyleAttr, defStyleRes)</code>。</p>

<p><strong>AttributeSet</strong> : layout文件中解析出来的属性对象集合，包含我们的样式。</p>

<p><strong>attrs</strong>: 前面讲到的一组相关联的属性集合。<code>com.android.internal.R.styleable.TextView</code> 可在AOSP中查看具体有哪些属性，这里列出一部分：</p>

<pre><code class="xml"> &lt;declare-styleable name="TextView"&gt;
        &lt;!-- Determines the minimum type that getText() will return.
             The default is "normal".
             Note that EditText and LogTextBox always return Editable,
             even if you specify something less powerful here. --&gt;
        &lt;attr name="bufferType"&gt;
            &lt;!-- Can return any CharSequence, possibly a
             Spanned one if the source text was Spanned. --&gt;
            &lt;enum name="normal" value="0" /&gt;
            &lt;!-- Can only return Spannable. --&gt;
            &lt;enum name="spannable" value="1" /&gt;
            &lt;!-- Can only return Spannable and Editable. --&gt;
            &lt;enum name="editable" value="2" /&gt;
        &lt;/attr&gt;
        &lt;!-- Text to display. --&gt;
        &lt;attr name="text" format="string" localization="suggested" /&gt;
        &lt;!-- Hint text to display when the text is empty. --&gt;
        &lt;attr name="hint" format="string" /&gt;
        &lt;!-- Text color. --&gt;
        &lt;attr name="textColor" /&gt;
        &lt;!-- Color of the text selection highlight. --&gt;
        &lt;attr name="textColorHighlight" /&gt;
        &lt;!-- Color of the hint text. --&gt;
        &lt;attr name="textColorHint" /&gt;
        &lt;!-- Base text color, typeface, size, and style. --&gt;
        &lt;attr name="textAppearance" /&gt;
        &lt;!-- Size of the text. Recommended dimension type for text is "sp" for scaled-pixels (example: 15sp). --&gt;
        &lt;attr name="textSize" /&gt;
        &lt;!-- Sets the horizontal scaling factor for the text. --&gt;
        &lt;attr name="textScaleX" format="float" /&gt;

   &lt;!--省略不少--&gt;
</code></pre>

<p><strong>defStyleAttr</strong> ： 一个指定的属性资源。在这里为 <code>com.android.internal.R.attr.textViewStyle</code>（2个参数的构造方法传进来的）。可以在<strong>Theme</strong>中找到此属性对应的值，对应了一个Style.</p>

<pre><code class="xml">&lt;item name="textViewStyle"&gt;@style/Widget.Material.Light.TextView&lt;/item&gt;
</code></pre>

<p><strong>defStyleRes</strong>:  Style资源，也是一组样式。</p>

<p>以上，<code>context.obtainStyledAttributes</code>  获取View样式的过程为：</p>

<ol>
<li><p>从AttributeSet样式集合中寻找<code>int[] attrs</code>指定的几个属性对应的值。例如：xml中指定了<code>android:textColor="#ff0000"</code>， attrs属性组中定义有<code>textColor</code>这个属性，则提取出来。</p></li>
<li><p>如果AttributeSet中没有要提取的样式（比如，以上没有指定textColor样式），则根据<strong>defStyleAttr</strong>来从指定的<strong>Theme</strong>中寻找样式。比如：Material主题中指定了:</p></li>
</ol>


<pre><code class="xml">&lt;item name="textViewStyle"&gt;@style/Widget.Material.Light.TextView&lt;/item&gt;
</code></pre>

<p>则进一步去<code>@style/Widget.Material.Light.TextView</code> 中寻找想要的样式。</p>

<ol>
<li>如果主题中仍然找不到要提取的样式。 则去<strong>defStyleRes</strong>(我们指定的Style样式中)寻找。</li>
</ol>


<h3>另外</h3>

<p>经过上面的分析，已经可以知道Theme是怎样应用默认样式到View上的了，因此我们就可以修改这种默认样式来定制我们自己的主题。比如我们想让默认的Button控件字体为30sp。</p>

<p>```xml</p>







<pre><code>
首先，自定义**CustomTheme**继承Andorid的Theme，复写**buttonStyle**指向我们自定义的样式。

其次，定义我们自己的Button样式，可以继承原来的样式，复写textSize属性，来修改默认的Button字体大小。



### 再另外

前面提到**Theme**中会有一些Window的样式，我们可以复写来实现一些window的效果.比如
</code></pre>



<p>```</p>

<p>这些属性在PhoneWindow的generateLayout方法中被解析和应用。</p>

<h3>相关资料</h3>

<ul>
<li>Android源码分析</li>
<li><a href="http://www.jianshu.com/p/d147608dc27b">Android沉浸状态栏的实现</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
